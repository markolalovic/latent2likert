data.frame(n, k, alpha, power)
n = seq(100, 200, 25)
n
k = qbinom(0.05, n, 0.3) - 1
k
alpha = pbinom(k, n, 0.3)
power = pbinom(k, n, 0.2)
data.frame(n, k, alpha, power)
n = seq(100, 200, 25)
k = qbinom(0.05, n, 0.3) - 1
alpha = pbinom(k, n, 0.3)
power = pbinom(k, n, 0.2)
data.frame(n, k, alpha, power)
n = seq(100, 200, 25)
k = qbinom(0.05, n, 0.05) - 1
alpha = pbinom(k, n, 0.05)
power = pbinom(k, n, 0.05)
data.frame(n, k, alpha, power)
n = seq(300, 500, 25)
k = qbinom(0.05, n, 0.05) - 1
alpha = pbinom(k, n, 0.05)
power = pbinom(k, n, 0.05)
data.frame(n, k, alpha, power)
n = seq(300, 500, 25)
k = qbinom(0.05, n, 0.05) - 1
alpha = pbinom(k, n, 0.05)
power = pbinom(k, n, 0.025)
data.frame(n, k, alpha, power)
n = seq(300, 600, 25)
k = qbinom(0.05, n, 0.05) - 1
alpha = pbinom(k, n, 0.05)
power = pbinom(k, n, 0.025)
data.frame(n, k, alpha, power)
n = seq(300, 600, 50)
k = qbinom(0.05, n, 0.05) - 1
alpha = pbinom(k, n, 0.05)
power = pbinom(k, n, 0.025)
data.frame(n, k, alpha, power)
n = seq(300, 600, 100)
k = qbinom(0.05, n, 0.05) - 1
alpha = pbinom(k, n, 0.05)
power = pbinom(k, n, 0.025)
data.frame(n, k, alpha, power)
n = seq(300, 600, 100)
x = qbinom(0.05, n, 0.05) - 1
alpha = pbinom(x, n, 0.05)
beta = pbinom(x, n, 0.025)
data.frame(n, x, alpha, beta)
library(hexSticker) # Create Hexagon Sticker in R
library(hexSticker) # Create Hexagon Sticker in R
install.packages('hexSticker', dependencies = TRUE, repos='http://cran.rstudio.com/')
install.packages('ggimage', dependencies = TRUE, repos='http://cran.rstudio.com/')
remotes::install_github("GuangchuangYu/hexSticker")
install.packages('remotes', dependencies = TRUE, repos='http://cran.rstudio.com/')
remotes::install_github("GuangchuangYu/hexSticker")
ggplot(as.data.frame(Titanic),
aes(y = Freq,
axis1 = Class, axis2 = Sex, axis3 = Age,
fill = Survived)) +
geom_alluvium() +
scale_x_discrete(limits = c("Class", "Sex", "Age"))
install.packages('ggplot', dependencies = TRUE, repos='http://cran.rstudio.com/')
install.packages('ggplot2', dependencies = TRUE, repos='http://cran.rstudio.com/')
ggplot(as.data.frame(Titanic),
aes(y = Freq,
axis1 = Class, axis2 = Sex, axis3 = Age,
fill = Survived)) +
geom_alluvium() +
scale_x_discrete(limits = c("Class", "Sex", "Age"))
ggplot2(as.data.frame(Titanic),
aes(y = Freq,
axis1 = Class, axis2 = Sex, axis3 = Age,
fill = Survived)) +
geom_alluvium() +
scale_x_discrete(limits = c("Class", "Sex", "Age"))
ggplot(as.data.frame(Titanic),
aes(y = Freq,
axis1 = Class, axis2 = Sex, axis3 = Age,
fill = Survived)) +
geom_alluvium() +
scale_x_discrete(limits = c("Class", "Sex", "Age"))
library('ggplot')
library('ggplot2')
ggplot(as.data.frame(Titanic),
aes(y = Freq,
axis1 = Class, axis2 = Sex, axis3 = Age,
fill = Survived)) +
geom_alluvium() +
scale_x_discrete(limits = c("Class", "Sex", "Age"))
install.packages("ggalluvial")
library(ggalluvial)
ggplot(as.data.frame(Titanic),
aes(y = Freq,
axis1 = Class, axis2 = Sex, axis3 = Age,
fill = Survived)) +
geom_alluvium() +
scale_x_discrete(limits = c("Class", "Sex", "Age"))
ggplot(df, aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node), label = node)) +
geom_alluvial(flow.alpha = .6) +
geom_alluvial_text(size = 3, color = "white") +
scale_fill_viridis_d() +
theme_alluvial(base_size = 18) +
labs(x = NULL) +
theme(legend.position = "none",
plot.title = element_text(hjust = .5)) +
ggtitle("Car features")
devtools::install_github("davidsjoberg/ggsankey")
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
devtools::install_github("davidsjoberg/ggsankey")
library('devtools')
install.packages("devtools", dependencies = TRUE)
install.packages("pkgdown", dependencies = TRUE)
devtools::install_github("davidsjoberg/ggsankey")
install.packages("hexSticker")
install.package("remotes")
install.packages("remotes")
remotes::install_github("GuangchuangYu/hexSticker")
library(hexSticker) # Create Hexagon Sticker in R
install.packages("hexSticker")
setwd("/home/marko/repos/responsesR/")
set.seed(1234)
source("responses.R")
library(corrplot)
df <- genLikert(size=100, items=5)
head(df)
df <- genLikert(size=100, items=5)
head(df)
getwd()
setwd("/home/marko/repos/responsesR/R")
set.seed(1234)
source("responses.R")
library(corrplot)
# Quick Start
df <- genLikert(size=100, items=5)
head(df)
par(mfrow=c(1, 5))
for(i in 1:5) {
barplot(table(df[, i]))
}
# Quick Start
df <- genLikert(size = 100, items = 10)
head(df)
par(mfrow=c(1, 5))
par(mfrow=c(2, 5))
for(i in 1:10) {
barplot(table(df[, i]))
}
res <- cor(df)
round(res, 2)
par(mfrow=c(1, 1))
corrplot(corr=res)
# By default, the genLikert function uses a random correlation matrix.
res <- cor(df)
round(res, 2)
par(mfrow=c(1, 1))
corrplot(corr=res)
# By default, the genLikert function uses a random correlation matrix.
par(mfrow=c(1, 1))
corrplot(corr=cor(df))
#
df <- genLikert(size = 100, items = 10, correlation = 0.5)
par(mfrow=c(1, 1))
corrplot(corr=cor(df))
corrplot(corr=cor(df), method="number")
corrplot(corr=cor(df))
# In order to set a specific correlation between pairs of items,
# for example, 0.5, use:
df <- genLikert(size = 100, items = 10, correlation = 0.5)
par(mfrow=c(1, 1))
corrplot(corr=cor(df))
# You can also provide a correlation matrix
R <- c(1.00, -0.63, -0.39, -0.63, 1.00, 0.41, -0.39, 0.41, 1.00)
R <- matrix(R, nrow=3)
R
df <- genLikert(size = 100, items = 3, correlation = R)
par(mfrow=c(1, 1))
corrplot(corr=cor(df))
corrplot(corr=cor(df), method = "number")
setwd("/home/marko/repos/responsesR/R")
set.seed(1234)
source("responses.R")
library(corrplot)
# Quick Start
# To generate a sample of 100 observations for 10 Likert scale items:
df <- genLikert(size = 100, items = 10)
head(df)
# The result is a data frame of simulated responses where rows correspond to
# observations and columns correspond to Likert scale items:
par(mfrow=c(2, 5))
for(i in 1:10) {
barplot(table(df[, i]))
}
# By default, a correlation matrix is generated randomly,
# which means that the correlations between items are random:
par(mfrow=c(1, 1))
corrplot(corr=cor(df))
# In order to set a specific correlation between pairs of items,
# for example, 0.5, use:
df <- genLikert(size = 100, items = 10, correlation = 0.5)
par(mfrow=c(1, 1))
corrplot(corr=cor(df))
# You can also provide a correlation matrix. For example, a 3 by 3 correlation
# matrix for 3 Likert scale items:
R <- c(1.00, -0.63, -0.39, -0.63, 1.00, 0.41, -0.39, 0.41, 1.00)
R <- matrix(R, nrow=3)
R
df <- genLikert(size = 100, items = 3, correlation = R)
corrplot(corr=cor(df), method = "number")
setwd("/home/marko/repos/responsesR/R")
set.seed(12345)
source("responses.R")
library(corrplot)
# Quick Start
# To generate a sample of 100 observations for 10 Likert scale items:
df <- genLikert(size = 100, items = 10)
head(df)
# The result is a data frame of simulated responses where rows correspond to
# observations and columns correspond to Likert scale items:
par(mfrow=c(2, 5))
for(i in 1:10) {
barplot(table(df[, i]))
}
# By default, a correlation matrix is generated randomly,
# which means that the correlations between items are random:
par(mfrow=c(1, 1))
corrplot(corr=cor(df))
# In order to set a specific correlation between pairs of items,
# for example, 0.5, use:
df <- genLikert(size = 100, items = 10, correlation = 0.5)
par(mfrow=c(1, 1))
corrplot(corr=cor(df))
# You can also provide a correlation matrix. For example, a 3 by 3 correlation
# matrix for 3 Likert scale items:
R <- c(1.00, -0.63, -0.39, -0.63, 1.00, 0.41, -0.39, 0.41, 1.00)
R <- matrix(R, nrow=3)
R
df <- genLikert(size = 100, items = 3, correlation = R)
corrplot(corr=cor(df), method = "number")
set.seed(12345)
df <- genLikert(size = 100, items = 3, correlation = R)
corrplot(corr=cor(df), method = "number")
## Levels
# By default, genLikert function uses a 5-point Likert scale.
# To change the number of possible responses use the "levels" parameter.
# For example, for a 10-point Likert scale use levels = 10:
df <- genLikert(size = 100, items = 1, levels=10)
df
barplot(table(df))
par(mfrow=c(1, 3))
sapply(1:3, barplot(df[, i]))
sapply(1:3, barplot(table(df[, i])))
# To generate items with different point scales
# You can also provide a levels vector. For example for 3 Likert scale items
# with 2, 4 and 10-point Likert scales:
df <- genLikert(size = 100, items = 3, levels=c(2, 4, 10))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# You can use a levels vector to generate responses for different point scales.
# For example, to generate responses to 3 Likert scale items with 2, 4, and 10-point
# Likert scales, use:
df <- genLikert(size = 100, items = 3, levels=c(2, 4, 10))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
## Location, scale and shape parameters
# By default, the function genLikert generates symmetrically distributed responses
# from a standard normal distribution.
# This can be observed by increasing the sample size and number of levels:
df <- genLikert(size = 10^6, levels = 100)
par(mfrow=c(1, 1))
barplot(table(df)/10^6)
df <- genLikert(size = 10^6, levels = 100, location = 1)
par(mfrow=c(1, 1))
barplot(table(df)/10^6)
# Introducing asymmetries and changing the properties of hypothetical survey
# respondents can be achieved by utilizing parameters location, scale, and shape.
df <- genLikert(size = 100, items = 3, location = c(-1, 0, 1))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# The scale vector is used to change the variance:
df <- genLikert(size = 100, items = 3, scale = c(0.2, 1, 1.2))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# The scale vector is used to change the variance:
df <- genLikert(size = 1000, items = 3, scale = c(0.2, 1, 1.2))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# You can use a location vector to generate responses from latent distributions
# with different means. As an example, let's the means -1, 0, and 1:
df <- genLikert(size = 1000, items = 3, location = c(-1, 0, 1))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# The scale vector is used to change the variance:
df <- genLikert(size = 1000, items = 3, scale = c(0.2, 1, 1.2))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
df <- genLikert(size = 1000, items = 3, location = c(-1, 0, 1))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# The scale vector is used to change the variance:
df <- genLikert(size = 1000, items = 3, scale = c(0.2, 1, 1.2))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# The scale vector is used to change the variance:
df <- genLikert(size = 1000, items = 3, scale = c(0.5, 1, 1.2))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
df <- genLikert(size = 1000, items = 3, scale = c(0.5, 1, 1.5))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# Finally, the shape parameter can be used to introduce response bias or skewness.
df <- genLikert(size = 1000, items = 3, shape = c(-5, 0, 5))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# Finally, the shape parameter can be used to introduce response bias or skewness.
df <- genLikert(size = 1000, items = 3, levels=10 shape = c(-5, 0, 5))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# Finally, the shape parameter can be used to introduce response bias or skewness.
df <- genLikert(size = 1000, items = 3, levels=10, shape = c(-5, 0, 5))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# Finally, the shape parameter can be used to introduce response bias or skewness.
df <- genLikert(size = 1000, items = 3, levels=10, shape = c(-10, 0, 5))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# Finally, the shape parameter can be used to introduce response bias or skewness.
df <- genLikert(size = 1000, items = 3, levels=10, shape = c(-5, 0, 5))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
df <- genLikert(size = 1000, items = 3, levels=5, shape = c(-5, 0, 5))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
df <- genLikert(size = 1000, items = 3, shape = c(-5, 0, 5))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
df <- genLikert(size = 10^6, levels = 100, shape = -5)
par(mfrow=c(1, 1))
barplot(table(df)/10^6)
df <- genLikert(size = 1000, items = 3, shape = c(-5, 0, 5))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# When shape != 0, the function genLikert uses skew-normal distribution
# This can be observed by increasing the sample size and number of levels:
df <- genLikert(size = 10^6, levels = 100, shape = -5)
par(mfrow=c(1, 1))
barplot(table(df)/10^6)
# Finally, the shape parameter can be used to introduce response bias or skewness.
df <- genLikert(size = 1000, items = 3, shape = c(-5, 0, 5))
par(mfrow=c(1, 3))
for(i in 1:3) {
barplot(table(df[, i]))
}
# When shape != 0, the function genLikert uses skew-normal distribution
# This can be observed by increasing the sample size and number of levels:
df <- genLikert(size = 10^6, levels = 100, shape = -5)
par(mfrow=c(1, 1))
barplot(table(df)/10^6)
setwd("/home/marko/repos/responsesR/R")
set.seed(12345)
source("responses.R")
library(corrplot)
# Quick Start
# To generate a sample of 100 observations for 10 Likert scale items:
df <- genLikert(size = 100, items = 10)
head(df)
